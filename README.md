# AEC_ML_MCA_MAR_2023

**GMeet Link:**<br>
https://meet.google.com/ugx-iskt-vbc

**Online Session MS-Teams Link for all sessions:**<br>
https://tinyurl.com/2xfbsmfs

**Project Group Formation (1) Link for Batch-1:**<br>
https://bit.ly/3JCZdCx

# Python_Notes

<hr>

**Python Download Link:**<br>
**Anaconda Download Link:**<br>
https://www.anaconda.com/products/distribution

**Online Python Editors:**<br>
https://onecompiler.com/<br>
https://www.onlinegdb.com/

**Python Study Material Links:**<br>
**Python for you and me:** https://pymbook.readthedocs.io/en/latest/<br>
**Python Practice Book:** https://anandology.com/python-practice-book/index.html<br>
**Learn Python Programming (programmiz.com):** https://www.programiz.com/python-programming<br>
**Learn Python Programming (data-flair):** https://data-flair.training/blogs/python-tutorial/

<hr>

### Features of Python
Python is a popular high-level programming language that is used for various purposes such as web development, data analysis, artificial intelligence, scientific computing, and more. Some of the key features of Python include:

* **Easy to Learn and Use:** Python has a simple and easy-to-understand syntax that makes it easy for developers to write code quickly and efficiently. Its readability makes it an excellent choice for beginners who are just starting out in programming.

* **Open-Source:** Python is an open-source programming language, which means it is free to use, distribute, and modify. This makes it accessible to anyone who wants to use it, including individuals, businesses, and organizations.

* **Cross-Platform:** Python can run on a variety of operating systems, including Windows, Mac, and Linux. This makes it a versatile language that can be used on different platforms and devices.

* **Rich Library Support:** Python has a vast library of modules and packages that can be used for various purposes, such as data analysis, web development, machine learning, and more. These libraries make it easy for developers to write complex applications quickly and efficiently.

* **High-Level Language:** Python is a high-level language, which means it abstracts away much of the low-level details of programming, such as memory management and pointer manipulation. This allows developers to focus on solving problems and writing code, rather than worrying about the low-level details.

* **Dynamically Typed:** Python is a dynamically typed language, which means the data types of variables are determined at runtime. This makes it easy for developers to write code quickly, as they do not need to declare variable types in advance.

* **Object-Oriented:** Python is an object-oriented language, which means it uses classes and objects to represent real-world entities and concepts. This makes it easy for developers to write modular and reusable code.

* **Community Support:** Python has a large and active community of developers who contribute to the language and its libraries. This community support makes it easy for developers to find help and resources when needed.

<hr>

### Applications of Python
Python is a versatile programming language that can be used for various applications in different domains. Some of the common applications of Python are:

* **Web Development:** Python can be used to develop web applications using frameworks such as Django, Flask, Pyramid, and Bottle. These frameworks provide a simple and easy-to-use interface for developers to create web applications quickly.

* **Data Analysis and Visualization:** Python has various libraries such as NumPy, Pandas, Matplotlib, and Seaborn that provide powerful tools for data analysis and visualization. These libraries make it easy for developers to analyze and visualize large amounts of data.

* **Machine Learning and Artificial Intelligence:** Python is widely used in the field of machine learning and artificial intelligence. Libraries such as TensorFlow, Keras, Scikit-learn, and PyTorch provide powerful tools for building machine learning models.

* **Scientific Computing:** Python is used extensively in scientific computing due to its ability to handle complex mathematical calculations. Libraries such as SciPy and NumPy provide tools for numerical computing, scientific visualization, and signal processing.

* **Desktop Applications:** Python can be used to develop desktop applications using frameworks such as PyQt, wxPython, and PyGTK. These frameworks provide a simple and easy-to-use interface for building cross-platform desktop applications.

* **Game Development:** Python can be used to develop games using libraries such as Pygame and Panda3D. These libraries provide tools for creating 2D and 3D games.

* **Automation and Scripting:** Python can be used for automation and scripting tasks, such as web scraping, data processing, and system administration. Its simple and easy-to-use syntax makes it an excellent choice for scripting tasks.

Overall, Python's versatility and ease of use make it an excellent choice for a wide range of applications, from web development and data analysis to machine learning and scientific computing.

<hr>

### Python Datatypes
Python has several built-in datatypes, including:

* **Integer (int):** This datatype represents whole numbers, both positive and negative.

* **Float:** This datatype represents real numbers with decimal points.

* **Boolean (bool):** This datatype represents a binary value, either True or False.

* **String (str):** This datatype represents a sequence of characters, enclosed in single or double quotes.

* **List:** This datatype represents an ordered collection of items, enclosed in square brackets and separated by commas.

* **Tuple:** This datatype is similar to a list, but its values are enclosed in parentheses and cannot be modified once created.

* **Set:** This datatype represents an unordered collection of unique items, enclosed in curly braces.

* **Dictionary:** This datatype represents a collection of key-value pairs, enclosed in curly braces and separated by colons.

* **None:** This datatype represents the absence of a value and is often used to represent a null value or default value.

These datatypes can be used to store and manipulate data in Python programs. Python also allows for dynamic typing, meaning that variables can change datatypes during runtime.

<hr>

### Python Operators
Python operators are symbols that allow you to perform operations on one or more values or variables. Python provides various types of operators:

* **Arithmetic Operators:** Arithmetic operators are used to perform mathematical operations like addition, subtraction, multiplication, division, modulus, and exponentiation.

Examples:

<pre>
+   # addition
-   # subtraction
*   # multiplication
/   # division
%   # modulus
**  # exponentiation
//  # floor division
</pre>

* **Comparison Operators:** Comparison operators are used to compare two values and return True or False.

Examples:

<pre>
==  # equal to
!=  # not equal to
<   # less than
&gt;   # greater than
<=  # less than or equal to
>=  # greater than or equal to
</pre>

* **Logical Operators:** Logical operators are used to combine two or more conditions and return True or False.

Examples:

<pre>
and  # logical AND
or   # logical OR
not  # logical NOT
</pre>

* **Assignment Operators:** Assignment operators are used to assign values to variables.

Examples:

<pre>
=   # assign a value
+=  # add and assign
-=  # subtract and assign
*=  # multiply and assign
/=  # divide and assign
%=  # modulus and assign
**= # exponentiate and assign
//= # floor divide and assign
</pre>

* **Bitwise Operators:** Bitwise operators are used to perform bitwise operations on integers.

Examples:

<pre>
&   # bitwise AND
|   # bitwise OR
^   # bitwise XOR
~   # bitwise NOT
<<  # bitwise left shift
>>  # bitwise right shift
</pre>

* **Membership Operators:** Membership operators are used to test if a sequence is present in an object.

Examples:

<pre>
in    # test if a value is present in a sequence
not in # test if a value is not present in a sequence
</pre>

* **Identity Operators:** Identity operators are used to compare the memory location of two objects.

Examples:

<pre>
is    # test if two variables refer to the same object
is not # test if two variables do not refer to the same object
</pre>

<hr>

### Conditional Statements in Python
In Python, conditional statements are used to control the flow of execution based on certain conditions. The most common conditional statements are if, elif, and else.

The basic syntax of an if statement is as follows:

<pre>
if condition:
    statement(s)
</pre>

Here, condition is an expression that is evaluated to either True or False. If the condition is True, then the statement(s) inside the if block are executed. If the condition is False, then the statement(s) inside the if block are skipped.

For example:

<pre>
x = 5
if x &gt; 0:
    print("x is positive")
</pre>

This code will print "x is positive", since the condition x &gt; 0 is True.

The elif statement is used to add additional conditions to an if statement. The syntax is as follows:

<pre>
if condition1:
    statement(s)
elif condition2:
    statement(s)
elif condition3:
    statement(s)
else:
    statement(s)
</pre>

Here, elif stands for "else if". If the first if condition is False, then the elif conditions are evaluated in order. If a condition is True, then the corresponding statement(s) are executed and the rest of the elif conditions are skipped. If all elif conditions are False, then the else block (if present) is executed.

For example:

<pre>
x = 0
if x &gt; 0:
    print("x is positive")
elif x == 0:
    print("x is zero")
else:
    print("x is negative")
</pre>

This code will print "x is zero", since the first condition is False, the second condition is True, and the third condition is skipped.

It's also possible to use nested if statements to create more complex conditions. For example:

<pre>
x = 5
if x &gt; 0:
    if x &lt; 10:
        print("x is a single digit positive number")
    else:
        print("x is a positive number greater than or equal to 10")
else:
    print("x is not a positive number")
</pre>

This code will print "x is a single digit positive number", since both conditions are True.

<hr>

### Python Loops
In Python, loops are used to repeat a block of code multiple times. There are two main types of loops: for loops and while loops.

A for loop is used to iterate over a sequence (such as a list, tuple, or string) or any iterable object. The basic syntax of a for loop is as follows:

<pre>
for variable in sequence:
    statement(s)
</pre>

Here, sequence is a sequence or iterable object, and variable is a variable that takes on the value of each element in the sequence one at a time. The statement(s) inside the loop are executed for each value of variable in the sequence.

For example:

<pre>
my_list = [1, 2, 3, 4, 5]
for i in my_list:
    print(i)
</pre>

This code will print the values 1 through 5, since the variable i takes on the values of each element in my_list one at a time.

A while loop is used to repeat a block of code as long as a certain condition is True. The basic syntax of a while loop is as follows:

<pre>
while condition:
    statement(s)
</pre>

Here, condition is an expression that is evaluated to either True or False. The statement(s) inside the loop are executed as long as the condition is True.

For example:

<pre>
i = 0
while i &lt; 5:
    print(i)
    i += 1
</pre>

This code will print the values 0 through 4, since the loop will continue as long as i is less than 5.

Both for and while loops can be controlled using the break and continue statements. The break statement is used to exit the loop prematurely, while the continue statement is used to skip the current iteration of the loop and move on to the next one.

For example:

<pre>
my_list = [1, 2, 3, 4, 5]
for i in my_list:
    if i == 3:
        break
    print(i)
</pre>

This code will print the values 1 and 2, since the loop will exit when i is equal to 3.

<pre>
my_list = [1, 2, 3, 4, 5]
for i in my_list:
    if i == 3:
        continue
    print(i)
</pre>

This code will print the values 1, 2, 4, and 5, since the loop will skip the iteration when i is equal to 3.

<hr>

### User Defined Functions (UDFs) in Python
In Python, you can define your own functions to perform specific tasks. Functions are a way to group code that performs a specific task, which makes it easier to reuse the code and keep your programs organized.

The basic syntax for defining a function in Python is as follows:

<pre>
def function_name(parameters):
    statement(s)
    return value
</pre>

Here, function_name is the name of the function, and parameters is a comma-separated list of input parameters that the function takes. The statement(s) inside the function perform the task that the function is designed to do, and the return statement returns a value (if necessary).

For example, here is a function that takes two parameters and returns their sum:

<pre>
def add_numbers(x, y):
    result = x + y
    return result
</pre>

To call this function, you simply pass in the required parameters:

<pre>
sum = add_numbers(5, 10)
print(sum)
</pre>

This code will output 15, since the add_numbers function takes the parameters 5 and 10, adds them together, and returns the result.

Functions can also have optional parameters with default values. Here's an example:

<pre>
def greet(name, greeting="Hello"):
    print(greeting + ", " + name)
</pre>

In this case, the greeting parameter is optional and has a default value of "Hello". You can call the function with or without the greeting parameter:

<pre>
greet("Alice")
greet("Bob", "Hi")
</pre>

This code will output:

<pre>
Hello, Alice
Hi, Bob
</pre>

Functions can also have variable-length argument lists using *args and &ast;&ast;kwargs syntax. *args is used to pass a variable number of non-keyword arguments to the function, while &ast;&ast;kwargs is used to pass a variable number of keyword arguments to the function. Here's an example:

<pre>
def my_function(*args, **kwargs):
    print(args)
    print(kwargs)
</pre>

You can call this function with any number of arguments:

<pre>
my_function(1, 2, 3, name="Alice", age=30)
</pre>

This code will output:

<pre>
(1, 2, 3)
{'name': 'Alice', 'age': 30}
</pre>

This function takes three non-keyword arguments and two keyword arguments, and prints them out using the args and kwargs parameters.

<hr>

### What are the features of functional programming?
Functional programming is a programming paradigm that emphasizes the use of functions to solve problems. Here are some of the key features of functional programming:

* **Functions as First-Class Citizens:** In functional programming, functions are treated as first-class citizens (or also called first-class objects), which means they can be assigned to variables, passed as arguments to other functions, and returned as values from functions.

* **Immutable Data:** Functional programming languages discourage or prohibit the changing of state or mutable data. Instead, they emphasize the use of immutable data structures that don't change during the program execution.

* **Pure Functions:** Pure functions are functions that do not have any side effects and return the same output for the same input every time. Pure functions are free from any external dependencies or state changes, making them easier to test and reason about.

* **Higher-Order Functions:** Functional programming languages often have support for higher-order functions, which are functions that can take other functions as arguments or return functions as values. Higher-order functions can be used to create abstractions and solve problems in a more concise way.

* **Recursion:** Functional programming languages typically use recursion as a primary means of iteration. Instead of using loops to iterate through data, functions are called recursively with new input until a base case is reached.

* **Lazy Evaluation:** Lazy evaluation is a feature of some functional programming languages where expressions are only evaluated when needed, rather than eagerly evaluated at the time they are defined. This can lead to improved performance and more efficient use of resources.

* **Declarative Style:** Functional programming languages encourage a declarative programming style where programs are written as a series of expressions that describe what the program should do, rather than how to do it. This can make programs easier to read and understand.

### What are the features of lambda function in Python?
In Python programming, a lambda function is a small anonymous function that can have any number of arguments, but can only have one expression. The expression is evaluated and returned as the function result. Lambda functions are commonly used in combination with higher-order functions such as map(), filter(), and reduce().

Some of the properties of lambda functions in Python programming include:
* **Anonymous:** Lambda functions are anonymous, meaning they do not have a name like regular functions. They are defined using the keyword "lambda" followed by the arguments and the expression.
* **Single Expression:** A lambda function can only contain a single expression that is evaluated and returned as the function result. This means that it cannot contain multiple statements or control flow structures.
* **Concise:** Lambda functions are concise and can be defined in a single line of code. This makes them useful for defining simple functions on-the-fly.
* **Immutable:** Lambda functions are immutable, meaning they cannot be modified once defined. This means that you cannot change the behavior of a lambda function after it has been defined.
* **Higher-order Functions:** Lambda functions are often used in combination with higher-order functions such as map(), filter(), and reduce(). These functions take other functions as arguments and return new functions as results.
* **Memory-efficient:** Lambda functions are memory-efficient since they are defined on-the-fly and do not require a separate function definition. This can be useful when working with large data sets or when memory usage is a concern.
* **One-Liners:** Lambda functions are often used for simple, one-liner operations such as filtering, sorting, or mapping data.
* **Functional Programming:** Lambda functions are a key feature of functional programming in Python, allowing for higher-order functions and other functional programming techniques.
* **Variables:** Lambda functions can use variables from the enclosing scope, which can be useful in some cases. However, this can lead to unexpected behavior if not used carefully.

### How to use lambda functions in Python?
A lambda function is a small, anonymous function in Python that can be defined without a name. It is also called a lambda expression or a lambda abstraction.

The syntax for a lambda function is:<br>
**lambda arguments: expression**<br>
The arguments are the inputs to the function and the expression is the operation performed on the input. The lambda function returns the result of the expression.

Here's an example of a lambda function that adds two numbers:<br>
**add = lambda x, y: x + y**<br>
The add lambda function takes two arguments x and y, and returns their sum.

Lambda functions are often used as a quick and easy way to define simple functions that are only used once. For example, suppose you have a list of numbers and you want to sort them in descending order. You can use the built-in sorted function with a lambda function as the key parameter:<br>
**numbers = [5, 2, 8, 1, 3]<br>
sorted_numbers = sorted(numbers, key=lambda x: -x)<br>
print(sorted_numbers)  # prints [8, 5, 3, 2, 1]**<br>
In this example, the lambda function lambda x: -x is used as the key function for sorting the list in descending order. The lambda function takes one argument x and returns its negation, which effectively reverses the order of the numbers.

<hr>

### Exception handling in Python
In Python, exception handling is a way to deal with errors that may occur during the execution of a program. When an error occurs, an exception is raised. If this exception is not caught and handled, the program will terminate with an error message. However, by using exception handling, you can catch the exception and handle it in a way that allows the program to continue running.

URL for Python Exception Hierarchy: https://docs.python.org/3/library/exceptions.html<br>

To handle exceptions in Python, you use the try and except statements. The try statement encloses a block of code that may raise an exception. The except statement specifies how to handle the exception that is raised. Here's an example:


try:
    # code that may raise an exception
except ExceptionType:
    # code to handle the exception

In this example, ExceptionType is the type of exception that you want to catch. If an exception of this type is raised within the try block, the code in the except block will be executed. If no exception is raised, the code in the except block will be skipped.

You can also use multiple except statements to handle different types of exceptions. For example:

<pre>
try:
    # code that may raise an exception
except ExceptionType1:
    # code to handle the first type of exception
except ExceptionType2:
    # code to handle the second type of exception
</pre>

In this example, if an exception of ExceptionType1 is raised, the first except block will be executed. If an exception of ExceptionType2 is raised, the second except block will be executed.

You can also use a finally block to specify code that will always be executed, whether an exception is raised or not. For example:

<pre>
try:
    # code that may raise an exception
except ExceptionType:
    # code to handle the exception
finally:
    # code that will always be executed
</pre>

In this example, the code in the finally block will be executed whether an exception is raised or not. This can be useful for cleaning up resources or closing files, for example.

You can also raise your own exceptions using the raise statement. For example:

<pre>
if x &lt; 0:
    raise ValueError("x cannot be negative")
</pre>

In this example, if x is negative, a ValueError exception will be raised with the message "x cannot be negative".

<hr>

### Module in Python
In Python, a module is a file containing Python code that defines variables, functions, and classes that can be used in other Python programs. A module can be thought of as a library of code that can be reused in multiple programs.

To use a module in your Python program, you first need to import it. You can import a module using the import statement followed by the name of the module. For example, to import the math module, you would use the following statement:

<pre>
import math
</pre>

Once you have imported the module, you can use its functions and variables in your program by referencing them with the module name. For example, to use the sqrt function from the math module to calculate the square root of a number, you would use the following code:

<pre>
import math

x = 16
y = math.sqrt(x)
print(y)
</pre>

This code will output 4.0, since the square root of 16 is 4.

You can also import specific functions or variables from a module using the from keyword. For example, to import only the sqrt function from the math module, you would use the following statement:

<pre>
from math import sqrt
</pre>

This allows you to use the sqrt function directly in your code without having to reference the math module:

<pre>
from math import sqrt

x = 16
y = sqrt(x)
print(y)
</pre>

This code will output 4.0, just like the previous example.

Python comes with a number of built-in modules that provide useful functionality, such as os (for operating system functions), random (for generating random numbers), and datetime (for working with dates and times). You can also create your own modules by defining functions and variables in a Python file and then importing that file as a module in other programs.

<hr>

### Math Module in Python
The math module in Python provides various mathematical functions for performing mathematical operations in Python. Here are some of the commonly used functions from the math module:

* **math.ceil(x):** Returns the smallest integer greater than or equal to x.
* **math.floor(x):** Returns the largest integer less than or equal to x.
* **math.sqrt(x):** Returns the square root of x.
* **math.pow(x, y):** Returns x raised to the power of y.
* **math.exp(x):** Returns the exponential value of x.
* **math.log(x):** Returns the natural logarithm of x.
* **math.log10(x):** Returns the base-10 logarithm of x.
* **math.radia**ns(x):** Converts x from degrees to radians.
* **math.degr**ees(x):** Converts x from radians to degrees.
* **math.sin(x):** Returns the sine of x.
* **math.cos(x):** Returns the cosine of x.
* **math.tan(x):** Returns the tangent of x.
* **math.asin(x):** Returns the inverse sine of x.
* **math.acos(x):** Returns the inverse cosine of x.
* **math.atan(x):** Returns the inverse tangent of x.
* **math.pi:** Returns the value of pi (3.141592653589793).
* **math.e:** Returns the value of e (2.718281828459045).

To use these functions, you need to import the math module at the beginning of your program using the following code:

<pre>
import math
</pre>

Once you have imported the math module, you can call any of its functions using the dot notation, like this:

<pre>
import math

x = 10
y = 2

print(math.ceil(x/y))  # Output: 5
print(math.sqrt(x))  # Output: 3.1622776601683795
print(math.sin(math.radians(90)))  # Output: 1.0
</pre>

These are just a few examples of the many functions available in the math module. You can refer to the official Python documentation for more information on the math module and its functions.

<hr>

### Inbuilt Collections in Python
Python comes with several built-in collections that are commonly used in programming. Here are some of the most commonly used inbuilt collections:

* **Lists:** Lists are ordered collections of items that can be of different data types. Lists are mutable, meaning they can be modified after creation. You can create a list in Python by enclosing a comma-separated sequence of elements in square brackets.

<pre>
my_list = [1, 2, 3, 'four', 'five']
</pre>

* **Tuples:** Tuples are similar to lists, but they are immutable, meaning that they cannot be modified after creation. Tuples are commonly used to group related values together. You can create a tuple in Python by enclosing a comma-separated sequence of elements in parentheses.

<pre>
my_tuple = (1, 2, 3, 'four', 'five')
</pre>

* **Sets:** Sets are unordered collections of unique items. Sets are useful for removing duplicates from a list and performing set operations like union, intersection, and difference. You can create a set in Python by enclosing a comma-separated sequence of elements in curly braces, or by using the set() function.

<pre>
my_set = {1, 2, 3, 4, 5}
</pre>

* **Dictionaries:** Dictionaries are unordered collections of key-value pairs. Dictionaries are useful for storing and retrieving data based on a key. You can create a dictionary in Python by enclosing a comma-separated sequence of key-value pairs in curly braces, or by using the dict() function.

<pre>
my_dict = {'name': 'John', 'age': 30, 'gender': 'male'}
</pre>

* **Strings:** Strings are collections of characters. Strings are immutable, meaning they cannot be modified after creation. You can create a string in Python by enclosing a sequence of characters in single or double quotes.

<pre>
my_string = 'Hello, World!'
</pre>

These are just a few of the most commonly used inbuilt collections in Python. There are many other collections provided by the Python standard library and third-party packages that you can use in your programs.

<hr>

### String in Python
In Python, a string is a sequence of characters. It is one of the basic data types used in Python programming. Strings are defined using single quotes ('...') or double quotes ("..."). For example:

<pre>
my_string = "Hello, World!"
</pre>

This creates a string named my_string with the value "Hello, World!".

Strings can be concatenated (combined) using the + operator. For example:

<pre>
greeting = "Hello"
name = "Alice"
message = greeting + ", " + name + "!"
print(message)  # prints "Hello, Alice!"
</pre>

Strings can be indexed and sliced to access individual characters or substrings. Indexing starts from 0, and negative indexing is allowed, which starts from the end of the string (-1). Slicing is done using the colon operator :. For example:

<pre>
my_string = "Hello, World!"
print(my_string[0])     # prints "H"
print(my_string[-1])    # prints "!"
print(my_string[7:12])  # prints "World"
</pre>

Strings are immutable, which means you cannot modify a string once it has been created. However, you can create a new string by slicing and concatenating parts of the original string. For example:

<pre>
my_string = "Hello, World!"
new_string = my_string[:5] + "Python!"
print(new_string)  # prints "HelloPython!"
</pre>

Strings also support various methods for manipulating and formatting them. For example:

<pre>
my_string = "   Hello, World!   "
print(my_string.strip())  # removes whitespace from both ends of the string

my_string = "Hello, World!"
print(my_string.lower())  # converts the string to lowercase
print(my_string.upper())  # converts the string to uppercase

my_string = "Hello, {name}!"
print(my_string.format(name="Alice"))  # prints "Hello, Alice!"
</pre>

These are just a few examples of the many operations that can be performed on strings in Python.

<hr>

### List in Python
In Python, a list is a collection of items (values or objects) which are ordered and mutable. It is one of the most commonly used data structures in Python programming. A list can contain items of different data types such as integers, floats, strings, and even other lists.

Lists are defined using square brackets [] and commas to separate the items. For example:

<pre>
my_list = [1, 2, 3, 4, 5]
This creates a list named my_list with five integer items.
</pre>

You can access individual items in a list by their index (position) in the list, starting from 0. For example:

<pre>
my_list = [1, 2, 3, 4, 5]
print(my_list[0])  # prints 1
print(my_list[2])  # prints 3
</pre>

Lists are mutable, which means you can change, add or remove items after the list has been created. You can modify an item in a list by assigning a new value to it:

<pre>
my_list = [1, 2, 3, 4, 5]
my_list[2] = 10
print(my_list)  # prints [1, 2, 10, 4, 5]
</pre>

You can add items to a list using the append() method or the insert() method. For example:

<pre>
my_list = [1, 2, 3, 4, 5]
my_list.append(6)
print(my_list)  # prints [1, 2, 3, 4, 5, 6]

my_list.insert(2, 10)
print(my_list)  # prints [1, 2, 10, 3, 4, 5, 6]
</pre>

You can remove items from a list using the remove() method or the pop() method. For example:

<pre>
my_list = [1, 2, 3, 4, 5]
my_list.remove(3)
print(my_list)  # prints [1, 2, 4, 5]

popped_item = my_list.pop()
print(my_list)      # prints [1, 2, 4]
print(popped_item)  # prints 5
</pre>

Lists can also be sliced to create new lists with a subset of the original items. For example:

<pre>
my_list = [1, 2, 3, 4, 5]
new_list = my_list[1:4]
print(new_list)  # prints [2, 3, 4]
</pre>

Lists can also be nested, which means you can have lists within lists. For example:

<pre>
my_list = [1, [2, 3], 4, [5, 6, 7]]
print(my_list[1][0])  # prints 2
</pre>

<hr>

### Tuple in Python
In Python, a tuple is a collection of items (values or objects) which are ordered and immutable. It is similar to a list, but unlike a list, a tuple cannot be modified once it has been created. Tuples are defined using parentheses () and commas to separate the items. For example:

<pre>
my_tuple = (1, 2, 3, 4, 5)
</pre>

This creates a tuple named my_tuple with five integer items.

You can access individual items in a tuple by their index (position) in the tuple, starting from 0. For example:

<pre>
my_tuple = (1, 2, 3, 4, 5)
print(my_tuple[0])  # prints 1
print(my_tuple[2])  # prints 3
</pre>

Since tuples are immutable, you cannot modify an item in a tuple once it has been created. However, you can create a new tuple by concatenating two or more tuples using the + operator. For example:

<pre>
my_tuple = (1, 2, 3)
new_tuple = my_tuple + (4, 5)
print(new_tuple)  # prints (1, 2, 3, 4, 5)
</pre>

You can also create a new tuple by slicing a subset of the original items. For example:

<pre>
my_tuple = (1, 2, 3, 4, 5)
new_tuple = my_tuple[1:4]
print(new_tuple)  # prints (2, 3, 4)
</pre>

Tuples can be used as keys in dictionaries, while lists cannot. This is because dictionaries require keys to be immutable.

Tuples can be used to return multiple values from a function, which can be accessed using tuple unpacking. For example:

<pre>
def get_name_and_age():
    name = "John"
    age = 30
    return name, age

name, age = get_name_and_age()
print(name)  # prints "John"
print(age)   # prints 30
</pre>

In this example, the function get_name_and_age() returns a tuple of two values: name and age. The tuple is then unpacked into two variables name and age using tuple unpacking.

<hr>

### Dictionary in Python
A dictionary in Python is a collection of key-value pairs. Dictionaries are unordered and mutable, meaning that you can add, delete, and modify items in a dictionary after it has been created.

You can create a dictionary in Python by enclosing a comma-separated sequence of key-value pairs in curly braces {}, like this:

<pre>
my_dict = {'name': 'John', 'age': 30, 'gender': 'male'}
</pre>

In the above example, the keys are 'name', 'age', and 'gender', and their corresponding values are 'John', 30, and 'male'.

You can access the values in a dictionary by referencing the keys, like this:

<pre>
name = my_dict['name']
age = my_dict['age']
gender = my_dict['gender']
</pre>

You can also use the get() method to retrieve the value associated with a key:

<pre>
name = my_dict.get('name')
age = my_dict.get('age')
gender = my_dict.get('gender')
</pre>

The get() method returns None if the key is not found in the dictionary, or a default value that you can specify as a second argument to the method.

You can add a new key-value pair to a dictionary like this:

<pre>
my_dict['email'] = 'john@example.com'
</pre>

And you can delete a key-value pair from a dictionary like this:

<pre>
del my_dict['gender']
</pre>

You can also update the value associated with a key in a dictionary like this:

<pre>
my_dict['age'] = 35
</pre>

Dictionaries are a useful data structure in Python because they allow you to associate values with keys, which can make your code more readable and easier to understand.

<hr>

### Set in Python
In Python, a set is an unordered collection of unique elements. Sets are mutable, which means you can add or remove elements from them after they have been created.

You can create a set in Python by enclosing a comma-separated sequence of values in curly braces {}, like this:

<pre>
my_set = {1, 2, 3, 4, 5}
</pre>

In the above example, my_set is a set containing the integers 1 through 5.

You can also create a set from a list using the set() function:

<pre>
my_list = [1, 2, 2, 3, 3, 4, 5]
my_set = set(my_list)
</pre>

In this case, the duplicates are removed from the list my_list and a set containing the unique elements is created.

You can add an element to a set using the add() method:

<pre>
my_set.add(6)
</pre>

And you can remove an element from a set using the remove() method:

<pre>
my_set.remove(3)
</pre>

You can also perform various set operations on sets, such as union, intersection, and difference. Here are some examples:

<pre>
set1 = {1, 2, 3, 4, 5}
set2 = {4, 5, 6, 7, 8}

# Union of set1 and set2
print(set1 | set2)  # Output: {1, 2, 3, 4, 5, 6, 7, 8}

# Intersection of set1 and set2
print(set1 & set2)  # Output: {4, 5}

# Difference of set1 and set2
print(set1 - set2)  # Output: {1, 2, 3}

# Symmetric difference of set1 and set2
print(set1 ^ set2)  # Output: {1, 2, 3, 6, 7, 8}
</pre>

In the above examples, | represents the union operator, & represents the intersection operator, - represents the difference operator, and ^ represents the symmetric difference operator.

Sets are a useful data structure in Python for storing unique elements and performing set operations.

<hr>

### Frozen Set in Python
In Python, a frozen set is an immutable version of a set. Once a frozen set is created, its elements cannot be added, removed, or modified.

You can create a frozen set in Python by enclosing a comma-separated sequence of values in the frozenset() function, like this:

<pre>
my_frozen_set = frozenset([1, 2, 3, 4, 5])
</pre>

In the above example, my_frozen_set is a frozen set containing the integers 1 through 5.

You can perform various set operations on frozen sets, such as union, intersection, and difference. Here are some examples:

<pre>
frozen_set1 = frozenset([1, 2, 3, 4, 5])
frozen_set2 = frozenset([4, 5, 6, 7, 8])

# Union of frozen_set1 and frozen_set2
print(frozen_set1 | frozen_set2)  # Output: frozenset({1, 2, 3, 4, 5, 6, 7, 8})

# Intersection of frozen_set1 and frozen_set2
print(frozen_set1 & frozen_set2)  # Output: frozenset({4, 5})

# Difference of frozen_set1 and frozen_set2
print(frozen_set1 - frozen_set2)  # Output: frozenset({1, 2, 3})

# Symmetric difference of frozen_set1 and frozen_set2
print(frozen_set1 ^ frozen_set2)  # Output: frozenset({1, 2, 3, 6, 7, 8})
</pre>

In the above examples, | represents the union operator, & represents the intersection operator, - represents the difference operator, and ^ represents the symmetric difference operator.

Frozen sets are useful in situations where you need a set that cannot be modified, such as when you want to use a set as a key in a dictionary or as an element in another set.

<hr>

# Object Oriented Programming Using Python

<hr>

### Object Oriented Programming in Python
Object-oriented programming (OOP) is a programming paradigm that allows you to create modular and reusable code by organizing data and behavior into objects. Python supports OOP, and in this answer, we'll cover some of the basic concepts of OOP in Python.

**Classes and Objects**
The building block of OOP in Python is a class. A class is a blueprint or template for creating objects. An object is an instance of a class, and it has its own unique data and behavior.

Here's an example of a simple class in Python:

<pre>
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def greet(self):
        print(f"Hello, my name is {self.name} and I am {self.age} years old.")
</pre>

In this example, we have defined a class called Person. The &lowbar;&lowbar;init&lowbar;&lowbar; method is a special method in Python that is called when an object is created. It initializes the object with the given name and age attributes. The greet method is a simple method that prints a message introducing the person.

To create an object of the Person class, we can do the following:

<pre>
person = Person("Alice", 25)
person.greet()  # prints "Hello, my name is Alice and I am 25 years old."
</pre>

In this example, we have created a Person object with the name "Alice" and the age 25. We have then called the greet method on the person object, which prints a message introducing the person.

**Inheritance**<br><br>
One of the key features of OOP is inheritance. Inheritance allows you to create a new class that is a modified version of an existing class. The new class inherits the data and behavior of the existing class, but can also add its own data and behavior.

Here's an example of a Student class that inherits from the Person class:

<pre>
class Student(Person):
    def __init__(self, name, age, grade):
        super().__init__(name, age)
        self.grade = grade

    def study(self):
        print(f"{self.name} is studying hard for the {self.grade} exam.")
</pre>

In this example, we have defined a Student class that inherits from the Person class. The &lowbar;&lowbar;init&lowbar;&lowbar; method of the Student class calls the &lowbar;&lowbar;init&lowbar;&lowbar; method of the Person class using the super() function, and then sets the grade attribute. The study method is a new method that is specific to the Student class.

To create a Student object, we can do the following:

<pre>
student = Student("Bob", 20, "history")
student.greet()  # prints "Hello, my name is Bob and I am 20 years old."
student.study()  # prints "Bob is studying hard for the history exam."
</pre>

In this example, we have created a Student object with the name "Bob", the age 20, and the grade "history". We have then called the greet method on the student object, which prints a message introducing the student, and the study method, which prints a message indicating that the student is studying.

**Polymorphism**<br><br>
Another key feature of OOP is polymorphism. Polymorphism allows you to use a single interface to represent multiple types of objects. In Python, polymorphism is achieved through method overriding and method overloading.

Method overriding is when a subclass provides its own implementation of a method

<hr>

### Static and Instance variables in Python
In Python, there are two types of variables: static variables and instance variables.

Static variables are shared across all instances of a class. They are defined inside the class, but outside of any method. You can access a static variable using the class name or an instance of the class. Here's an example:

<pre>
class MyClass:
    static_var = 0  # This is a static variable

    def __init__(self, instance_var):
        self.instance_var = instance_var  # This is an instance variable
</pre>

In this example, static_var is a static variable that is shared across all instances of the MyClass class. You can access it using the class name:

<pre>
print(MyClass.static_var)  # prints "0"
</pre>

You can also access it using an instance of the class:

<pre>
obj = MyClass(10)
print(obj.static_var)  # prints "0"
</pre>

However, if you change the value of a static variable using an instance of the class, it will only affect that instance and not the class as a whole:

<pre>
obj.static_var = 1
print(MyClass.static_var)  # prints "0"
print(obj.static_var)      # prints "1"
</pre>

Instance variables, on the other hand, are unique to each instance of a class. They are defined inside the &lowbar;&lowbar;init&lowbar;&lowbar; method and are accessed using the self keyword. Here's an example:

<pre>
class MyClass:
    static_var = 0  # This is a static variable

    def __init__(self, instance_var):
        self.instance_var = instance_var  # This is an instance variable
</pre>

In this example, instance_var is an instance variable that is unique to each instance of the MyClass class. You can access it using an instance of the class:

<pre>
obj = MyClass(10)
print(obj.instance_var)  # prints "10"
</pre>

Each instance of the class has its own copy of the instance variable, which can be set independently:

<pre>
obj1 = MyClass(10)
obj2 = MyClass(20)
print(obj1.instance_var)  # prints "10"
print(obj2.instance_var)  # prints "20"
</pre>

In summary, static variables are shared across all instances of a class, while instance variables are unique to each instance of a class. Both types of variables can be useful in different situations, depending on the needs of your program.

<hr>

### Instance, Class and Static methods in Python
In Python, there are three types of methods that can be defined within a class: instance methods, class methods, and static methods.

**Instance Methods:**
Instance methods are the most common type of method in Python. They are defined inside a class and operate on an instance of that class. An instance method takes the instance itself as the first argument, which is usually called "self". Using the "self" parameter, instance methods can access and modify the attributes of the instance.
Here's an example of an instance method:

<pre>
class MyClass:
    def instance_method(self, arg1, arg2):
        self.arg1 = arg1
        self.arg2 = arg2
</pre>

In this example, "instance_method" is an instance method that takes two arguments "arg1" and "arg2". It also modifies the attributes "arg1" and "arg2" of the instance using the "self" parameter.

**Class Methods:**
Class methods are methods that are bound to the class and not the instance of the class. They are defined with a special decorator "@classmethod" and take the class itself as the first argument, which is usually called "cls". Class methods can access and modify the class-level attributes and perform operations that are specific to the class.
Here's an example of a class method:

<pre>
class MyClass:
    class_attr = 0
    
    @classmethod
    def class_method(cls, arg):
        cls.class_attr += arg
</pre>

In this example, "class_method" is a class method that takes one argument "arg". It modifies the class-level attribute "class_attr" using the "cls" parameter.

**Static Methods:**
Static methods are methods that do not depend on the instance or the class. They are defined with a special decorator "@staticmethod" and do not take any special parameters. Static methods can be used to group related utility functions within a class.
Here's an example of a static method:

<pre>
class MyClass:
    @staticmethod
    def static_method(arg):
        return arg * arg
</pre>

In this example, "static_method" is a static method that takes one argument "arg". It returns the square of the argument.

To call these methods, you need to create an instance of the class for instance methods, use the class name for class methods and static methods:

<pre>
obj = MyClass()
obj.instance_method(1, 2)
MyClass.class_method(3)
MyClass.static_method(4)
</pre>

<hr>

### Magic Variables in Python (&lowbar;&lowbar;variablename&lowbar;&lowbar;)
In Python, magic variables refer to a set of predefined variables that are created and updated by the interpreter as you execute your code. These variables provide useful information about the current state of your program and can help you debug or optimize your code.

Here are some of the most commonly used magic variables in Python:

* **name:** This variable contains the name of the current module. If the module is being run as the main program, its value will be "main".

* **file:** This variable contains the filename of the current module.

* **doc:** This variable contains the docstring (documentation string) for the current module or function.

* **all:** This variable is a list of public names that should be imported when a module is imported using the "from module import *" syntax.

* **dict:** This variable contains the namespace of the current module or class.

* **dir:** This variable returns a list of all the names defined in the current namespace.

* **file and line:** These variables are used by the traceback module to report the file name and line number of an exception.

* **builtins:** This variable is a module containing all the built-in functions and variables of Python.

* **package:** This variable contains the name of the current package. If the module is not part of a package, its value will be None.

Magic variables in Python are identified by their double underscore prefix and suffix. These variables are created and updated by the Python interpreter and are not intended to be modified by the user. Instead, they provide useful information that can be used to improve the quality and efficiency of your code.

<hr>

### Magic Methods in Python (&lowbar;&lowbar;methodname&lowbar;&lowbar;)
Magic methods in Python are special methods that are identified by double underscores (e.g., init, str) and are used to define how objects of a class behave in certain situations. These methods are also known as dunder methods.

Here are some of the most commonly used magic methods in Python:

* **init(self, ...):** This method is called when an object is created and is used to initialize the object's attributes.

* **str(self):** This method is used to return a string representation of the object.

* **repr(self):** This method is used to return a string representation of the object that can be used to recreate the object.

* **eq(self, other):** This method is used to test whether two objects are equal.

* **lt(self, other):** This method is used to test whether one object is less than another.

* **gt(self, other):** This method is used to test whether one object is greater than another.

* **len(self):** This method is used to return the length of the object.

* **getitem(self, key):** This method is used to get the value of an item in the object, using the key.

* **setitem(self, key, value):** This method is used to set the value of an item in the object, using the key.

* **delitem(self, key):** This method is used to delete an item from the object, using the key.

* **iter(self):** This method is used to define an iterator for the object.

* **next(self):** This method is used to get the next item from the iterator.

* **call(self, ...):** This method is used to make an object callable like a function.

Magic methods in Python are a powerful tool for creating custom classes that behave like built-in types. By implementing these methods, you can define how objects of your class should behave in various situations, making your code more expressive and flexible.

<hr>

### Public, Protected and Private Access Modifiers in Python
In Python, there are three access modifiers that are used to control the visibility and accessibility of class members, including variables and methods. These access modifiers are:

* **Public:** By default, all class members are public in Python, which means they can be accessed from anywhere, inside or outside of the class. You can access public members using the dot notation, such as object_name.member_name.

* **Protected:** In Python, a single underscore (_) before a variable or method name indicates that it is protected. This means that the member can be accessed from within the class and its subclasses, but not from outside the class. However, this is more of a convention and not strictly enforced by the language.

* **Private:** In Python, a double underscore (__) before a variable or method name indicates that it is private. This means that the member can only be accessed from within the class, and cannot be accessed from outside the class, even from its subclasses. However, you can still access private members using the name mangling technique, which involves adding an underscore and the class name before the member name, such as object_name._class_name__member_name.

Here is an example to demonstrate these access modifiers in Python:

<pre>
class MyClass:
    def __init__(self):
        self.public_var = "This is a public variable"
        self._protected_var = "This is a protected variable"
        self.__private_var = "This is a private variable"
    
    def public_method(self):
        print("This is a public method")
    
    def _protected_method(self):
        print("This is a protected method")
    
    def __private_method(self):
        print("This is a private method")

obj = MyClass()

# Accessing public members
print(obj.public_var)  # Output: This is a public variable
obj.public_method()   # Output: This is a public method

# Accessing protected members
print(obj._protected_var)  # Output: This is a protected variable
obj._protected_method()   # Output: This is a protected method

# Accessing private members
# This will raise an AttributeError
#print(obj.__private_var)
#print(obj.__private_method)

# Accessing private members using name mangling
print(obj._MyClass__private_var)  # Output: This is a private variable
obj._MyClass__private_method()   # Output: This is a private method
</pre>

<hr>

### Inheritance in Python
Inheritance is one of the key concepts in object-oriented programming (OOP), and Python supports it fully. Inheritance allows you to define a new class that is a modified version of an existing class, which is called the parent or base class. The new class is called the child or derived class. The child class inherits all the attributes and methods of the parent class and can also add new attributes and methods or modify the existing ones.

To create a new class that inherits from an existing class, you can use the following syntax:

<pre>
class ChildClass(ParentClass):
    # class definition
</pre>

This defines a new class called ChildClass that inherits from ParentClass.

When a child class is created, it inherits all the attributes and methods of the parent class. To access these attributes and methods, you can use the super() function. For example, to call a method of the parent class, you can use:

<pre>
super().parent_method(args)
</pre>

This calls the parent_method of the parent class with the given arguments.

You can also override methods of the parent class in the child class by defining a method with the same name in the child class. This is useful when you want to modify the behavior of a method in the parent class for the child class.

In addition to methods, you can also override attributes of the parent class in the child class. For example, you can define a new value for an attribute or delete it altogether.

Inheritance in Python is a powerful feature that allows you to reuse code and create more flexible and modular programs. By using inheritance, you can create new classes that build upon existing classes, without having to rewrite code.

<hr>

### Different types of Inheritances in Python
Inheritance is a fundamental concept of object-oriented programming (OOP) that allows classes to inherit properties and methods from other classes. In Python, there are several types of inheritance, including:

* **Single inheritance:** Single inheritance is the simplest type of inheritance in which a class inherits from a single parent class. The child class can access all the properties and methods of the parent class. To implement single inheritance, the child class is defined by inheriting from a single parent class using the syntax: class ChildClass(ParentClass):

* **Multiple inheritance:** Multiple inheritance is a type of inheritance in which a class inherits properties and methods from multiple parent classes. To implement multiple inheritance, the child class is defined by inheriting from two or more parent classes using the syntax: class ChildClass(ParentClass1, ParentClass2, ...):

* **Multi-level inheritance:** Multi-level inheritance is a type of inheritance in which a child class inherits properties and methods from a parent class, which in turn, inherits from another parent class. To implement multi-level inheritance, the child class is defined by inheriting from a parent class, which is defined by inheriting from another parent class using the syntax: class ChildClass(ParentClass1):

* **Hierarchical inheritance:** Hierarchical inheritance is a type of inheritance in which multiple child classes inherit properties and methods from a single parent class. To implement hierarchical inheritance, multiple child classes are defined by inheriting from a single parent class using the syntax: class ChildClass1(ParentClass): and class ChildClass2(ParentClass):

* **Hybrid inheritance:** Hybrid inheritance is a combination of two or more types of inheritance, such as multiple inheritance and multi-level inheritance. It allows for more complex inheritance hierarchies and provides greater flexibility in designing class structures.

In Python, inheritance is implemented using the "super()" method to call the parent class constructor and methods. The "super()" method allows child classes to access and inherit properties and methods from their parent classes.

<hr>

### Operator Overloading in Python
Operator overloading is a feature in Python that allows you to redefine the behavior of operators (+, -, *, /, ==, etc.) for objects of your own classes. This means that you can make your objects behave like built-in types when used with these operators.

For example, let's say you have a class called Vector that represents a mathematical vector with x and y components. You can define the behavior of the addition operator (+) for the Vector class so that it performs vector addition instead of just adding the x and y components separately:

<pre>
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)
</pre>

In this example, we have defined a Vector class with an &lowbar;&lowbar;add&lowbar;&lowbar; method that takes another Vector object as an argument and returns a new Vector object that represents the sum of the two vectors. We have used the + operator to call this method when adding two Vector objects together.

Here's an example of how to use this class:

<pre>
v1 = Vector(2, 3)
v2 = Vector(4, 5)
v3 = v1 + v2
print(v3.x, v3.y)  # prints "6 8"
</pre>

In this example, we have created two Vector objects v1 and v2, and added them together using the + operator. The result is a new Vector object v3 with x component of 6 and y component of 8.

In addition to the &lowbar;&lowbar;add&lowbar;&lowbar; method, there are many other methods that you can define to overload different operators in Python. Here are some common ones:

* **&lowbar;&lowbar;sub&lowbar;&lowbar;** (self, other): overload the subtraction operator (-)
* **&lowbar;&lowbar;mul&lowbar;&lowbar;(self, other):** overload the multiplication operator (*)
* **&lowbar;&lowbar;truediv&lowbar;&lowbar;(self, other):** overload the division operator (/)
* **&lowbar;&lowbar;eq&lowbar;&lowbar;(self, other):** overload the equality operator (==)
* **&lowbar;&lowbar;lt&lowbar;&lowbar;(self, other):** overload the less than operator (<)
* **&lowbar;&lowbar;gt&lowbar;&lowbar;(self, other):** overload the greater than operator (>)
* **&lowbar;&lowbar;str&lowbar;&lowbar;(self):** overload the string representation of an object (str())

Here's an example of overloading the multiplication operator for the Vector class:

<pre>
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __mul__(self, scalar):
        return Vector(self.x * scalar, self.y * scalar)
</pre>

In this example, we have defined a Vector class with an &lowbar;&lowbar;mul&lowbar;&lowbar; method that takes a scalar value as an argument and returns a new Vector object that represents the product of the vector and the scalar. We have used the * operator to call this method when multiplying a Vector object by a scalar.

Here's an example of how to use this class:

<pre>
v1 = Vector(2, 3)
v2 = v1 * 2
print(v2.x, v2.y)  # prints "4 6"
</pre>

In this example, we have created a Vector object v1 and multiplied it by a scalar value of 2 using the * operator. The result is a new Vector object v2 with x component of 4 and y component of 6.

Overall, operator overloading allows you to make your code more

<hr>

### Abstract Class in Python
In Python, an abstract class is a class that cannot be instantiated on its own and is meant to be subclassed by other classes. It provides a way to define a common interface for a set of subclasses, but allows each subclass to implement its own behavior.

To create an abstract class in Python, you need to use the abc module, which stands for "abstract base classes". Here's an example:

<pre>
import abc

class Shape(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def area(self):
        pass

    @abc.abstractmethod
    def perimeter(self):
        pass
</pre>

In this example, we have defined an abstract class called Shape that has two abstract methods: area and perimeter. These methods have no implementation and are marked with the @abc.abstractmethod decorator.

When you define an abstract class, you need to use the abc.ABCMeta metaclass, which tells Python that this class is abstract and cannot be instantiated directly.

Now, let's create a concrete subclass of Shape:

</pre>
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

    def perimeter(self):
        return 2 * (self.width + self.height)
</pre>

In this example, we have defined a concrete subclass of Shape called Rectangle. This class implements the area and perimeter methods, which are required by the Shape abstract class.

Note that if you try to create an instance of the Shape class directly, you will get a TypeError:

<pre>
s = Shape()  # Raises TypeError: Can't instantiate abstract class Shape with abstract methods area, perimeter
</pre>

This is because Shape is an abstract class and cannot be instantiated directly. Instead, you need to create an instance of a concrete subclass like Rectangle:

<pre>
r = Rectangle(2, 3)
print(r.area())       # prints "6"
print(r.perimeter())  # prints "10"
</pre>

In this example, we have created an instance of the Rectangle class and called its area and perimeter methods, which are implemented by the subclass.

Abstract classes are useful when you want to define a common interface for a set of related classes, but don't want to provide a concrete implementation for that interface. This allows you to create a flexible and extensible design that can be customized by subclasses.

<hr>

### Interface in Python
In Python, there is no built-in keyword for defining interfaces like in some other programming languages. However, you can create interfaces using abstract classes.

An interface in Python is a collection of abstract methods. These methods are declared but do not contain any implementation. A class that implements an interface must provide implementations for all the methods in the interface.

To create an interface in Python, you can use the abc module, which stands for "abstract base classes". Here's an example:

<pre>
import abc

class Shape(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def area(self):
        pass

    @abc.abstractmethod
    def perimeter(self):
        pass
</pre>

In this example, we have defined an interface called Shape that has two abstract methods: area and perimeter. These methods have no implementation and are marked with the @abc.abstractmethod decorator.

Now, let's create a class that implements the Shape interface:

<pre>
class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

    def perimeter(self):
        return 2 * (self.width + self.height)
</pre>

In this example, we have defined a class called Rectangle that implements the Shape interface by providing implementations for the area and perimeter methods.

Note that if you try to create a subclass of Shape that does not implement all the abstract methods, you will get a TypeError:

<pre>
class Square(Shape):
    def __init__(self, side):
        self.side = side

    def area(self):
        return self.side ** 2

# Raises TypeError: Can't instantiate abstract class Square with abstract methods perimeter
</pre>

This is because Square is a subclass of Shape and is required to implement all the abstract methods defined in the Shape interface.

Using interfaces in Python can help you write more modular and reusable code. By defining a clear and well-defined interface, you can decouple the implementation details of your code from its usage, making it easier to change and maintain over time.

<hr>

# SQLite Database

<hr>

### What is SQLite Database?
SQLite is a popular open-source relational database management system (RDBMS) that is widely used in applications that require a local data store. It is a software library that provides a lightweight disk-based database that doesn't require a separate server process and allows for self-contained, zero-configuration installation.

SQLite is ACID-compliant, which means that it guarantees the reliability and consistency of data even in the presence of hardware or software failures. It supports a wide range of standard SQL features, including transactions, indexes, views, triggers, and stored procedures, making it a powerful tool for managing and querying data.

SQLite is used in a variety of applications, including web browsers, mobile devices, desktop applications, and embedded systems. It is widely supported and has bindings for many programming languages, including Python, Java, C++, and Ruby, making it easy to integrate into different types of software applications. Because it is a lightweight and fast database system, it is often used in scenarios where high performance and low overhead are critical factors.

<hr>

### Features of SQLite
SQLite is a powerful and versatile database system that has a number of features that make it an attractive choice for many different types of applications. Some of the key features of SQLite include:

* **Lightweight and fast:** SQLite is a small, self-contained database engine that is optimized for performance and low memory usage. It doesn't require a separate server process or configuration, making it easy to deploy and use in a wide range of applications.

* **ACID-compliant:** SQLite is ACID-compliant, which means that it ensures the reliability and consistency of data, even in the presence of hardware or software failures. It supports atomic transactions, rollbacks, and other features that make it suitable for mission-critical applications.

* **Cross-platform:** SQLite is available on a wide range of platforms, including Windows, macOS, Linux, iOS, and Android. It also supports a range of programming languages, including Python, Java, C++, and Ruby, making it easy to integrate into many different types of applications.

* **Wide range of SQL features:** SQLite supports a broad range of SQL features, including complex queries, indexes, views, triggers, and stored procedures. It also has a powerful SQL query optimizer that can improve performance and reduce the amount of data that needs to be read from disk.

* **Flexible data types:** SQLite supports a range of data types, including integers, floating-point numbers, strings, and dates, as well as BLOBs (binary large objects) that can store images, audio files, and other binary data.

* **Embeddable:** SQLite can be embedded into other applications as a library, making it an attractive choice for software developers who need a local data store for their applications.

* **Public domain:** SQLite is released into the public domain, which means that it can be used, modified, and distributed without any restrictions. This makes it a popular choice for open-source projects and other applications that require a free and open-source database system.

<hr>

### Application of SQLite
SQLite is a versatile database system that can be used in a wide range of applications, including:

* **Mobile apps:** SQLite is widely used in mobile app development, particularly for Android and iOS platforms. It provides a lightweight and fast data storage solution that can be easily integrated into mobile apps.

* **Web browsers:** Many web browsers, including Firefox, Chrome, and Safari, use SQLite as a data storage mechanism for things like bookmarks, history, and other user data.

* **Desktop apps:** SQLite can be used as a local database for desktop applications, particularly those that require a small and fast data store. It can be easily integrated into applications written in a range of programming languages, including Python, Java, and C++.

* **Embedded systems:** SQLite can be embedded into a wide range of embedded systems, including IoT devices, medical devices, and automotive systems. It provides a fast and reliable data storage solution that can operate in resource-constrained environments.

* **Data analysis:** SQLite can be used as a lightweight data analysis tool for small datasets. It supports complex SQL queries and provides a range of tools for data analysis, including aggregations, grouping, and sorting.

* **Education:** SQLite is often used as a teaching tool for database systems and SQL. Its small size and ease of use make it an attractive choice for educators who want to introduce students to database concepts without the complexity of a full-featured database system.

Overall, SQLite is a versatile and powerful database system that can be used in a wide range of applications, from mobile apps to embedded systems to data analysis. Its lightweight and fast design, coupled with its broad support for SQL features, make it an attractive choice for many different types of applications.

<hr>

### SQLite in Python
SQLite is well-suited for use in Python applications because it is a lightweight database system that is easy to use and requires minimal setup. Python includes a built-in module called sqlite3 that provides a simple and efficient way to interact with SQLite databases from Python code.

Here is a brief example of how to use SQLite in Python:

<pre>
import sqlite3

# Connect to the database
conn = sqlite3.connect('example.db')

# Create a table
conn.execute('''CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY,
                name TEXT NOT NULL,
                age INTEGER)''')

# Insert some data
conn.execute("INSERT INTO users (name, age) VALUES ('Alice', 30)")
conn.execute("INSERT INTO users (name, age) VALUES ('Bob', 25)")

# Retrieve data
cursor = conn.execute("SELECT * FROM users")
for row in cursor:
    print(row)

# Close the database connection
conn.close()
</pre>

In this example, we first import the sqlite3 module and use the connect() method to create a connection to an SQLite database file called example.db. We then use SQL statements to create a table called users, insert some data into it, and retrieve all the data using a SELECT statement. Finally, we close the database connection using the close() method.

The sqlite3 module provides a convenient way to interact with SQLite databases from Python code, and it supports a wide range of SQL features, including transactions, indexes, views, and more.

<hr>

<pre>
Content of the dataset file name 'emp_data.csv'

1001,Dhiman,Kolkata,39000
1002,Anupam,Kolkata,25000
1003,Subham,Mumbai,36000
1004,Dinesh,Chennai,28000
1005,Kakali,Mumbai,25000
1006,Bimal,Hyderabad,30000
1007,Tarun,Chennai,17000
1008,Rittik,Durgapur,45000
1009,Barun,Hyderabad,39000
1010,Utpal,Lucknow,20000

</pre>

<hr>

Search on Google with the search string "SQLite Manager online".<br>
And click on the URL - https://extendsclass.com/sqlite-browser.html

<hr>
